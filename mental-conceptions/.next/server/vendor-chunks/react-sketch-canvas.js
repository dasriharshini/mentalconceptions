"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-sketch-canvas";
exports.ids = ["vendor-chunks/react-sketch-canvas"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-sketch-canvas/dist/react-sketch-canvas.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactSketchCanvas: () => (/* binding */ ReactSketchCanvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar runtime = {exports: {}};\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (module) {\nvar runtime = (function (exports) {\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined$1; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined$1) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined$1;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined$1;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined$1;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined$1, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined$1;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined$1;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined$1;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined$1;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports \n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n}(runtime));\n\nvar _regeneratorRuntime = runtime.exports;\n\n/**\r\n * Generate SVG Path tag from the given points\r\n */\n\nvar SvgPath = function SvgPath(_ref) {\n  var paths = _ref.paths,\n      id = _ref.id,\n      strokeWidth = _ref.strokeWidth,\n      strokeColor = _ref.strokeColor,\n      _ref$command = _ref.command,\n      command = _ref$command === void 0 ? bezierCommand : _ref$command;\n\n  if (paths.length === 1) {\n    var _paths$ = paths[0],\n        x = _paths$.x,\n        y = _paths$.y;\n    var radius = strokeWidth / 2;\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n      key: id,\n      id: id,\n      cx: x,\n      cy: y,\n      r: radius,\n      stroke: strokeColor,\n      fill: strokeColor\n    });\n  }\n\n  var d = paths.reduce(function (acc, point, i, a) {\n    return i === 0 ? \"M \" + point.x + \",\" + point.y : acc + \" \" + command(point, i, a);\n  }, '');\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    key: id,\n    id: id,\n    d: d,\n    fill: \"none\",\n    strokeLinecap: \"round\",\n    stroke: strokeColor,\n    strokeWidth: strokeWidth\n  });\n};\nvar line = function line(pointA, pointB) {\n  var lengthX = pointB.x - pointA.x;\n  var lengthY = pointB.y - pointA.y;\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nvar controlPoint = function controlPoint(controlPoints) {\n  var current = controlPoints.current,\n      next = controlPoints.next,\n      previous = controlPoints.previous,\n      reverse = controlPoints.reverse;\n  var p = previous || current;\n  var n = next || current;\n  var smoothing = 0.2;\n  var o = line(p, n);\n  var angle = o.angle + (reverse ? Math.PI : 0);\n  var length = o.length * smoothing;\n  var x = current.x + Math.cos(angle) * length;\n  var y = current.y + Math.sin(angle) * length;\n  return [x, y];\n};\n\nvar bezierCommand = function bezierCommand(point, i, a) {\n  var cpsX = null;\n  var cpsY = null;\n\n  switch (i) {\n    case 0:\n      var _controlPoint = controlPoint({\n        current: point\n      });\n\n      cpsX = _controlPoint[0];\n      cpsY = _controlPoint[1];\n      break;\n\n    case 1:\n      var _controlPoint2 = controlPoint({\n        current: a[i - 1],\n        next: point\n      });\n\n      cpsX = _controlPoint2[0];\n      cpsY = _controlPoint2[1];\n      break;\n\n    default:\n      var _controlPoint3 = controlPoint({\n        current: a[i - 1],\n        previous: a[i - 2],\n        next: point\n      });\n\n      cpsX = _controlPoint3[0];\n      cpsY = _controlPoint3[1];\n      break;\n  }\n\n  var _controlPoint4 = controlPoint({\n    current: point,\n    previous: a[i - 1],\n    next: a[i + 1],\n    reverse: true\n  }),\n      cpeX = _controlPoint4[0],\n      cpeY = _controlPoint4[1];\n\n  return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point.x + \", \" + point.y;\n};\n\nvar Paths = function Paths(_ref2) {\n  var id = _ref2.id,\n      paths = _ref2.paths;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, paths.map(function (path, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SvgPath, {\n      key: id + \"__\" + index,\n      paths: path.paths,\n      id: id + \"__\" + index,\n      strokeWidth: path.strokeWidth,\n      strokeColor: path.strokeColor,\n      command: bezierCommand\n    });\n  }));\n};\n\nvar loadImage = function loadImage(url) {\n  return new Promise(function (resolve, reject) {\n    var img = new Image();\n    img.addEventListener('load', function () {\n      if (img.width > 0) {\n        resolve(img);\n      }\n\n      reject('Image not found');\n    });\n    img.addEventListener('error', function (err) {\n      return reject(err);\n    });\n    img.src = url;\n    img.setAttribute('crossorigin', 'anonymous');\n  });\n};\n\nfunction getCanvasWithViewBox(canvas) {\n  var _canvas$firstChild;\n\n  var svgCanvas = (_canvas$firstChild = canvas.firstChild) == null ? void 0 : _canvas$firstChild.cloneNode(true);\n  var width = canvas.offsetWidth;\n  var height = canvas.offsetHeight;\n  svgCanvas.setAttribute('viewBox', \"0 0 \" + width + \" \" + height);\n  svgCanvas.setAttribute('width', width.toString());\n  svgCanvas.setAttribute('height', height.toString());\n  return {\n    svgCanvas: svgCanvas,\n    width: width,\n    height: height\n  };\n}\n\nvar Canvas = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {\n  var paths = props.paths,\n      isDrawing = props.isDrawing,\n      onPointerDown = props.onPointerDown,\n      onPointerMove = props.onPointerMove,\n      onPointerUp = props.onPointerUp,\n      _props$id = props.id,\n      id = _props$id === void 0 ? 'react-sketch-canvas' : _props$id,\n      _props$width = props.width,\n      width = _props$width === void 0 ? '100%' : _props$width,\n      _props$height = props.height,\n      height = _props$height === void 0 ? '100%' : _props$height,\n      _props$className = props.className,\n      className = _props$className === void 0 ? 'react-sketch-canvas' : _props$className,\n      _props$canvasColor = props.canvasColor,\n      canvasColor = _props$canvasColor === void 0 ? 'red' : _props$canvasColor,\n      _props$backgroundImag = props.backgroundImage,\n      backgroundImage = _props$backgroundImag === void 0 ? '' : _props$backgroundImag,\n      _props$exportWithBack = props.exportWithBackgroundImage,\n      exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack,\n      _props$preserveBackgr = props.preserveBackgroundImageAspectRatio,\n      preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? 'none' : _props$preserveBackgr,\n      _props$allowOnlyPoint = props.allowOnlyPointerType,\n      allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? 'all' : _props$allowOnlyPoint,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  } : _props$style,\n      _props$svgStyle = props.svgStyle,\n      svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle;\n  var canvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // Converts mouse coordinates to relative coordinate based on the absolute position of svg\n\n  var getCoordinates = function getCoordinates(pointerEvent) {\n    var _canvasRef$current, _window$scrollX, _window$scrollY;\n\n    var boundingArea = (_canvasRef$current = canvasRef.current) == null ? void 0 : _canvasRef$current.getBoundingClientRect();\n    var scrollLeft = (_window$scrollX = window.scrollX) != null ? _window$scrollX : 0;\n    var scrollTop = (_window$scrollY = window.scrollY) != null ? _window$scrollY : 0;\n\n    if (!boundingArea) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    var point = {\n      x: pointerEvent.pageX - boundingArea.left - scrollLeft,\n      y: pointerEvent.pageY - boundingArea.top - scrollTop\n    };\n    return point;\n  };\n  /* Mouse Handlers - Mouse down, move and up */\n\n\n  var handlePointerDown = function handlePointerDown(event) {\n    // Allow only chosen pointer type\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    if (event.pointerType === 'mouse' && event.button !== 0) return;\n    var point = getCoordinates(event);\n    onPointerDown(point);\n  };\n\n  var handlePointerMove = function handlePointerMove(event) {\n    if (!isDrawing) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    var point = getCoordinates(event);\n    onPointerMove(point);\n  };\n\n  var handlePointerUp = function handlePointerUp(event) {\n    if (event.pointerType === 'mouse' && event.button !== 0) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    onPointerUp();\n  };\n  /* Mouse Handlers ends */\n\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function () {\n    return {\n      exportImage: function exportImage(imageType) {\n        return new Promise( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n            var canvas, _getCanvasWithViewBox, svgCanvas, _width, _height, canvasSketch, loadImagePromises, img;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.prev = 0;\n                    canvas = canvasRef.current;\n\n                    if (canvas) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    throw Error('Canvas not rendered yet');\n\n                  case 4:\n                    _getCanvasWithViewBox = getCanvasWithViewBox(canvas), svgCanvas = _getCanvasWithViewBox.svgCanvas, _width = _getCanvasWithViewBox.width, _height = _getCanvasWithViewBox.height;\n                    canvasSketch = \"data:image/svg+xml;base64,\" + btoa(svgCanvas.outerHTML);\n                    _context.next = 8;\n                    return loadImage(canvasSketch);\n\n                  case 8:\n                    _context.t0 = _context.sent;\n                    loadImagePromises = [_context.t0];\n\n                    if (!exportWithBackgroundImage) {\n                      _context.next = 21;\n                      break;\n                    }\n\n                    _context.prev = 11;\n                    _context.next = 14;\n                    return loadImage(backgroundImage);\n\n                  case 14:\n                    img = _context.sent;\n                    loadImagePromises.push(img);\n                    _context.next = 21;\n                    break;\n\n                  case 18:\n                    _context.prev = 18;\n                    _context.t1 = _context[\"catch\"](11);\n                    console.warn('exportWithBackgroundImage props is set without a valid background image URL. This option is ignored');\n\n                  case 21:\n                    Promise.all(loadImagePromises).then(function (images) {\n                      var renderCanvas = document.createElement('canvas');\n                      renderCanvas.setAttribute('width', _width.toString());\n                      renderCanvas.setAttribute('height', _height.toString());\n                      var context = renderCanvas.getContext('2d');\n\n                      if (!context) {\n                        throw Error('Canvas not rendered yet');\n                      }\n\n                      images.reverse().forEach(function (image) {\n                        context.drawImage(image, 0, 0);\n                      });\n                      resolve(renderCanvas.toDataURL(\"image/\" + imageType));\n                    })[\"catch\"](function (e) {\n                      throw e;\n                    });\n                    _context.next = 27;\n                    break;\n\n                  case 24:\n                    _context.prev = 24;\n                    _context.t2 = _context[\"catch\"](0);\n                    reject(_context.t2);\n\n                  case 27:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, null, [[0, 24], [11, 18]]);\n          }));\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      },\n      exportSvg: function exportSvg() {\n        return new Promise(function (resolve, reject) {\n          try {\n            var _canvasRef$current2;\n\n            var canvas = (_canvasRef$current2 = canvasRef.current) != null ? _canvasRef$current2 : null;\n\n            if (canvas !== null) {\n              var _svgCanvas$querySelec, _svgCanvas$querySelec2;\n\n              var _getCanvasWithViewBox2 = getCanvasWithViewBox(canvas),\n                  svgCanvas = _getCanvasWithViewBox2.svgCanvas;\n\n              if (exportWithBackgroundImage) {\n                resolve(svgCanvas.outerHTML);\n                return;\n              }\n\n              (_svgCanvas$querySelec = svgCanvas.querySelector(\"#\" + id + \"__background\")) == null ? void 0 : _svgCanvas$querySelec.remove();\n              (_svgCanvas$querySelec2 = svgCanvas.querySelector(\"#\" + id + \"__canvas-background\")) == null ? void 0 : _svgCanvas$querySelec2.setAttribute('fill', canvasColor);\n              resolve(svgCanvas.outerHTML);\n            }\n\n            reject(new Error('Canvas not loaded'));\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }\n    };\n  });\n  /* Add event listener to Mouse up and Touch up to\r\n  release drawing even when point goes out of canvas */\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    document.addEventListener('pointerup', handlePointerUp);\n    return function () {\n      document.removeEventListener('pointerup', handlePointerUp);\n    };\n  }, [handlePointerUp]);\n  var eraserPaths = paths.filter(function (path) {\n    return !path.drawMode;\n  });\n  var currentGroup = 0;\n  var pathGroups = paths.reduce(function (arrayGroup, path) {\n    if (!path.drawMode) {\n      currentGroup += 1;\n      return arrayGroup;\n    }\n\n    if (arrayGroup[currentGroup] === undefined) {\n      arrayGroup[currentGroup] = [];\n    }\n\n    arrayGroup[currentGroup].push(path);\n    return arrayGroup;\n  }, [[]]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    role: \"presentation\",\n    ref: canvasRef,\n    className: className,\n    style: _extends({\n      touchAction: 'none',\n      width: width,\n      height: height\n    }, style),\n    \"touch-action\": \"none\",\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n    version: \"1.1\",\n    baseProfile: \"full\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    style: _extends({\n      width: '100%',\n      height: '100%'\n    }, svgStyle),\n    id: id\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    id: id + \"__eraser-stroke-group\",\n    display: \"none\"\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    id: id + \"__mask-background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: \"white\"\n  }), eraserPaths.map(function (eraserPath, i) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SvgPath, {\n      key: id + \"__eraser-\" + i,\n      id: id + \"__eraser-\" + i,\n      paths: eraserPath.paths,\n      strokeColor: \"#000000\",\n      strokeWidth: eraserPath.strokeWidth\n    });\n  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, backgroundImage && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pattern\", {\n    id: id + \"__background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    patternUnits: \"userSpaceOnUse\"\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"image\", {\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    xlinkHref: backgroundImage,\n    preserveAspectRatio: preserveBackgroundImageAspectRatio\n  })), eraserPaths.map(function (_, i) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"mask\", {\n      id: id + \"__eraser-mask-\" + i,\n      key: id + \"__eraser-mask-\" + i,\n      maskUnits: \"userSpaceOnUse\"\n    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"use\", {\n      href: \"#\" + id + \"__mask-background\"\n    }), Array.from({\n      length: eraserPaths.length - i\n    }, function (_, j) {\n      return j + i;\n    }).map(function (k) {\n      return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"use\", {\n        key: k.toString(),\n        href: \"#\" + id + \"__eraser-\" + k.toString()\n      });\n    }));\n  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    id: id + \"__canvas-background-group\"\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    id: id + \"__canvas-background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: backgroundImage ? \"url(#\" + id + \"__background)\" : canvasColor\n  })), pathGroups.map(function (pathGroup, i) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n      id: id + \"__stroke-group-\" + i,\n      key: id + \"__stroke-group-\" + i,\n      mask: \"url(#\" + id + \"__eraser-mask-\" + i + \")\"\n    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Paths, {\n      id: id,\n      paths: pathGroup\n    }));\n  })));\n});\n\nvar ReactSketchCanvas = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {\n  var _props$id = props.id,\n      id = _props$id === void 0 ? 'react-sketch-canvas' : _props$id,\n      _props$width = props.width,\n      width = _props$width === void 0 ? '100%' : _props$width,\n      _props$height = props.height,\n      height = _props$height === void 0 ? '100%' : _props$height,\n      _props$className = props.className,\n      className = _props$className === void 0 ? '' : _props$className,\n      _props$canvasColor = props.canvasColor,\n      canvasColor = _props$canvasColor === void 0 ? 'white' : _props$canvasColor,\n      _props$strokeColor = props.strokeColor,\n      strokeColor = _props$strokeColor === void 0 ? 'red' : _props$strokeColor,\n      _props$backgroundImag = props.backgroundImage,\n      backgroundImage = _props$backgroundImag === void 0 ? '' : _props$backgroundImag,\n      _props$exportWithBack = props.exportWithBackgroundImage,\n      exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack,\n      _props$preserveBackgr = props.preserveBackgroundImageAspectRatio,\n      preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? 'none' : _props$preserveBackgr,\n      _props$strokeWidth = props.strokeWidth,\n      strokeWidth = _props$strokeWidth === void 0 ? 4 : _props$strokeWidth,\n      _props$eraserWidth = props.eraserWidth,\n      eraserWidth = _props$eraserWidth === void 0 ? 8 : _props$eraserWidth,\n      _props$allowOnlyPoint = props.allowOnlyPointerType,\n      allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? 'all' : _props$allowOnlyPoint,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  } : _props$style,\n      _props$svgStyle = props.svgStyle,\n      svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle,\n      _props$onChange = props.onChange,\n      onChange = _props$onChange === void 0 ? function (_paths) {} : _props$onChange,\n      _props$onStroke = props.onStroke,\n      onStroke = _props$onStroke === void 0 ? function (_path, _isEraser) {} : _props$onStroke,\n      _props$withTimestamp = props.withTimestamp,\n      withTimestamp = _props$withTimestamp === void 0 ? false : _props$withTimestamp;\n  var svgCanvas = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(true),\n      drawMode = _React$useState[0],\n      setDrawMode = _React$useState[1];\n\n  var _React$useState2 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),\n      isDrawing = _React$useState2[0],\n      setIsDrawing = _React$useState2[1];\n\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),\n      resetStack = _React$useState3[0],\n      setResetStack = _React$useState3[1];\n\n  var _React$useState4 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),\n      undoStack = _React$useState4[0],\n      setUndoStack = _React$useState4[1];\n\n  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),\n      currentPaths = _React$useState5[0],\n      setCurrentPaths = _React$useState5[1];\n\n  var liftStrokeUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    var _currentPaths$slice$, _currentPaths$slice;\n\n    var lastStroke = (_currentPaths$slice$ = (_currentPaths$slice = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice[0]) != null ? _currentPaths$slice$ : null;\n\n    if (lastStroke === null) {\n      console.warn('No stroke found!');\n      return;\n    }\n\n    onStroke(lastStroke, !lastStroke.drawMode);\n  }, [isDrawing]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    liftStrokeUp();\n  }, [isDrawing]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    onChange(currentPaths);\n  }, [currentPaths]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function () {\n    return {\n      eraseMode: function eraseMode(erase) {\n        setDrawMode(!erase);\n      },\n      clearCanvas: function clearCanvas() {\n        setResetStack([].concat(currentPaths));\n        setCurrentPaths([]);\n      },\n      undo: function undo() {\n        // If there was a last reset then\n        if (resetStack.length !== 0) {\n          setCurrentPaths([].concat(resetStack));\n          setResetStack([]);\n          return;\n        }\n\n        setUndoStack(function (undoStack) {\n          return [].concat(undoStack, currentPaths.slice(-1));\n        });\n        setCurrentPaths(function (currentPaths) {\n          return currentPaths.slice(0, -1);\n        });\n      },\n      redo: function redo() {\n        // Nothing to Redo\n        if (undoStack.length === 0) return;\n        setCurrentPaths(function (currentPaths) {\n          return [].concat(currentPaths, undoStack.slice(-1));\n        });\n        setUndoStack(function (undoStack) {\n          return undoStack.slice(0, -1);\n        });\n      },\n      exportImage: function exportImage(imageType) {\n        var _svgCanvas$current;\n\n        var exportImage = (_svgCanvas$current = svgCanvas.current) == null ? void 0 : _svgCanvas$current.exportImage;\n\n        if (!exportImage) {\n          throw Error('Export function called before canvas loaded');\n        } else {\n          return exportImage(imageType);\n        }\n      },\n      exportSvg: function exportSvg() {\n        return new Promise(function (resolve, reject) {\n          var _svgCanvas$current2;\n\n          var exportSvg = (_svgCanvas$current2 = svgCanvas.current) == null ? void 0 : _svgCanvas$current2.exportSvg;\n\n          if (!exportSvg) {\n            reject(Error('Export function called before canvas loaded'));\n          } else {\n            exportSvg().then(function (data) {\n              resolve(data);\n            })[\"catch\"](function (e) {\n              reject(e);\n            });\n          }\n        });\n      },\n      exportPaths: function exportPaths() {\n        return new Promise(function (resolve, reject) {\n          try {\n            resolve(currentPaths);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      loadPaths: function loadPaths(paths) {\n        setCurrentPaths(function (currentPaths) {\n          return [].concat(currentPaths, paths);\n        });\n      },\n      getSketchingTime: function getSketchingTime() {\n        return new Promise(function (resolve, reject) {\n          if (!withTimestamp) {\n            reject(new Error(\"Set 'withTimestamp' prop to get sketching time\"));\n          }\n\n          try {\n            var sketchingTime = currentPaths.reduce(function (totalSketchingTime, path) {\n              var _path$startTimestamp, _path$endTimestamp;\n\n              var startTimestamp = (_path$startTimestamp = path.startTimestamp) != null ? _path$startTimestamp : 0;\n              var endTimestamp = (_path$endTimestamp = path.endTimestamp) != null ? _path$endTimestamp : 0;\n              return totalSketchingTime + (endTimestamp - startTimestamp);\n            }, 0);\n            resolve(sketchingTime);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      resetCanvas: function resetCanvas() {\n        setResetStack([]);\n        setUndoStack([]);\n        setCurrentPaths([]);\n      }\n    };\n  });\n\n  var handlePointerDown = function handlePointerDown(point) {\n    setIsDrawing(true);\n    setUndoStack([]);\n    var stroke = {\n      drawMode: drawMode,\n      strokeColor: drawMode ? strokeColor : '#000000',\n      strokeWidth: drawMode ? strokeWidth : eraserWidth,\n      paths: [point]\n    };\n\n    if (withTimestamp) {\n      stroke = _extends({}, stroke, {\n        startTimestamp: Date.now(),\n        endTimestamp: 0\n      });\n    }\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths, [stroke]);\n    });\n  };\n\n  var handlePointerMove = function handlePointerMove(point) {\n    if (!isDrawing) return;\n    var currentStroke = currentPaths.slice(-1)[0];\n\n    var updatedStroke = _extends({}, currentStroke, {\n      paths: [].concat(currentStroke.paths, [point])\n    });\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths.slice(0, -1), [updatedStroke]);\n    });\n  };\n\n  var handlePointerUp = function handlePointerUp() {\n    var _currentPaths$slice$2, _currentPaths$slice2;\n\n    if (!isDrawing) {\n      return;\n    }\n\n    setIsDrawing(false);\n\n    if (!withTimestamp) {\n      return;\n    }\n\n    var currentStroke = (_currentPaths$slice$2 = (_currentPaths$slice2 = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice2[0]) != null ? _currentPaths$slice$2 : null;\n\n    if (currentStroke === null) {\n      return;\n    }\n\n    var updatedStroke = _extends({}, currentStroke, {\n      endTimestamp: Date.now()\n    });\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths.slice(0, -1), [updatedStroke]);\n    });\n  };\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Canvas, {\n    ref: svgCanvas,\n    id: id,\n    width: width,\n    height: height,\n    className: className,\n    canvasColor: canvasColor,\n    backgroundImage: backgroundImage,\n    exportWithBackgroundImage: exportWithBackgroundImage,\n    preserveBackgroundImageAspectRatio: preserveBackgroundImageAspectRatio,\n    allowOnlyPointerType: allowOnlyPointerType,\n    style: style,\n    svgStyle: svgStyle,\n    paths: currentPaths,\n    isDrawing: isDrawing,\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp\n  });\n});\n\n\n//# sourceMappingURL=react-sketch-canvas.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2tldGNoLWNhbnZhcy9kaXN0L3JlYWN0LXNrZXRjaC1jYW52YXMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxnREFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQW1CLENBQUMsMkNBQWM7QUFDM0MsV0FBVyxnREFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDZDQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQsa0JBQWtCLHlDQUFZLFFBQVE7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsRUFBRSxzREFBeUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLGdEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxnREFBbUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLEVBQUUsZ0RBQW1CO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHLEVBQUUsZ0RBQW1CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLGdEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSSxnREFBbUIsa0NBQWtDLGdEQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsZ0RBQW1CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLGdEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsZ0RBQW1CO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGFBQWEsZ0RBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUcsSUFBSSxnREFBbUI7QUFDMUI7QUFDQSxHQUFHLEVBQUUsZ0RBQW1CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLGdEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsZ0RBQW1CO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQscUNBQXFDLDZDQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFlOztBQUVqQyx3QkFBd0IsMkNBQWM7QUFDdEM7QUFDQTs7QUFFQSx5QkFBeUIsMkNBQWM7QUFDdkM7QUFDQTs7QUFFQSx5QkFBeUIsMkNBQWM7QUFDdkM7QUFDQTs7QUFFQSx5QkFBeUIsMkNBQWM7QUFDdkM7QUFDQTs7QUFFQSx5QkFBeUIsMkNBQWM7QUFDdkM7QUFDQTs7QUFFQSxxQkFBcUIsOENBQWlCO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCxFQUFFLHNEQUF5QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxTQUFTLGdEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRW9DO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVudGFsLWNvbmNlcHRpb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNrZXRjaC1jYW52YXMvZGlzdC9yZWFjdC1za2V0Y2gtY2FudmFzLmVzbS5qcz84ZmI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBydW50aW1lID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQkMTsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQkMSkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkJDEsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkJDE7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgbW9kdWxlLmV4cG9ydHMgXG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG59KHJ1bnRpbWUpKTtcblxudmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lLmV4cG9ydHM7XG5cbi8qKlxyXG4gKiBHZW5lcmF0ZSBTVkcgUGF0aCB0YWcgZnJvbSB0aGUgZ2l2ZW4gcG9pbnRzXHJcbiAqL1xuXG52YXIgU3ZnUGF0aCA9IGZ1bmN0aW9uIFN2Z1BhdGgoX3JlZikge1xuICB2YXIgcGF0aHMgPSBfcmVmLnBhdGhzLFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlQ29sb3IgPSBfcmVmLnN0cm9rZUNvbG9yLFxuICAgICAgX3JlZiRjb21tYW5kID0gX3JlZi5jb21tYW5kLFxuICAgICAgY29tbWFuZCA9IF9yZWYkY29tbWFuZCA9PT0gdm9pZCAwID8gYmV6aWVyQ29tbWFuZCA6IF9yZWYkY29tbWFuZDtcblxuICBpZiAocGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIF9wYXRocyQgPSBwYXRoc1swXSxcbiAgICAgICAgeCA9IF9wYXRocyQueCxcbiAgICAgICAgeSA9IF9wYXRocyQueTtcbiAgICB2YXIgcmFkaXVzID0gc3Ryb2tlV2lkdGggLyAyO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICAgIGtleTogaWQsXG4gICAgICBpZDogaWQsXG4gICAgICBjeDogeCxcbiAgICAgIGN5OiB5LFxuICAgICAgcjogcmFkaXVzLFxuICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgIGZpbGw6IHN0cm9rZUNvbG9yXG4gICAgfSk7XG4gIH1cblxuICB2YXIgZCA9IHBhdGhzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwb2ludCwgaSwgYSkge1xuICAgIHJldHVybiBpID09PSAwID8gXCJNIFwiICsgcG9pbnQueCArIFwiLFwiICsgcG9pbnQueSA6IGFjYyArIFwiIFwiICsgY29tbWFuZChwb2ludCwgaSwgYSk7XG4gIH0sICcnKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBrZXk6IGlkLFxuICAgIGlkOiBpZCxcbiAgICBkOiBkLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICB9KTtcbn07XG52YXIgbGluZSA9IGZ1bmN0aW9uIGxpbmUocG9pbnRBLCBwb2ludEIpIHtcbiAgdmFyIGxlbmd0aFggPSBwb2ludEIueCAtIHBvaW50QS54O1xuICB2YXIgbGVuZ3RoWSA9IHBvaW50Qi55IC0gcG9pbnRBLnk7XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiBNYXRoLnNxcnQoTWF0aC5wb3cobGVuZ3RoWCwgMikgKyBNYXRoLnBvdyhsZW5ndGhZLCAyKSksXG4gICAgYW5nbGU6IE1hdGguYXRhbjIobGVuZ3RoWSwgbGVuZ3RoWClcbiAgfTtcbn07XG5cbnZhciBjb250cm9sUG9pbnQgPSBmdW5jdGlvbiBjb250cm9sUG9pbnQoY29udHJvbFBvaW50cykge1xuICB2YXIgY3VycmVudCA9IGNvbnRyb2xQb2ludHMuY3VycmVudCxcbiAgICAgIG5leHQgPSBjb250cm9sUG9pbnRzLm5leHQsXG4gICAgICBwcmV2aW91cyA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMsXG4gICAgICByZXZlcnNlID0gY29udHJvbFBvaW50cy5yZXZlcnNlO1xuICB2YXIgcCA9IHByZXZpb3VzIHx8IGN1cnJlbnQ7XG4gIHZhciBuID0gbmV4dCB8fCBjdXJyZW50O1xuICB2YXIgc21vb3RoaW5nID0gMC4yO1xuICB2YXIgbyA9IGxpbmUocCwgbik7XG4gIHZhciBhbmdsZSA9IG8uYW5nbGUgKyAocmV2ZXJzZSA/IE1hdGguUEkgOiAwKTtcbiAgdmFyIGxlbmd0aCA9IG8ubGVuZ3RoICogc21vb3RoaW5nO1xuICB2YXIgeCA9IGN1cnJlbnQueCArIE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aDtcbiAgdmFyIHkgPSBjdXJyZW50LnkgKyBNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGg7XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG52YXIgYmV6aWVyQ29tbWFuZCA9IGZ1bmN0aW9uIGJlemllckNvbW1hbmQocG9pbnQsIGksIGEpIHtcbiAgdmFyIGNwc1ggPSBudWxsO1xuICB2YXIgY3BzWSA9IG51bGw7XG5cbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdmFyIF9jb250cm9sUG9pbnQgPSBjb250cm9sUG9pbnQoe1xuICAgICAgICBjdXJyZW50OiBwb2ludFxuICAgICAgfSk7XG5cbiAgICAgIGNwc1ggPSBfY29udHJvbFBvaW50WzBdO1xuICAgICAgY3BzWSA9IF9jb250cm9sUG9pbnRbMV07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHZhciBfY29udHJvbFBvaW50MiA9IGNvbnRyb2xQb2ludCh7XG4gICAgICAgIGN1cnJlbnQ6IGFbaSAtIDFdLFxuICAgICAgICBuZXh0OiBwb2ludFxuICAgICAgfSk7XG5cbiAgICAgIGNwc1ggPSBfY29udHJvbFBvaW50MlswXTtcbiAgICAgIGNwc1kgPSBfY29udHJvbFBvaW50MlsxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBfY29udHJvbFBvaW50MyA9IGNvbnRyb2xQb2ludCh7XG4gICAgICAgIGN1cnJlbnQ6IGFbaSAtIDFdLFxuICAgICAgICBwcmV2aW91czogYVtpIC0gMl0sXG4gICAgICAgIG5leHQ6IHBvaW50XG4gICAgICB9KTtcblxuICAgICAgY3BzWCA9IF9jb250cm9sUG9pbnQzWzBdO1xuICAgICAgY3BzWSA9IF9jb250cm9sUG9pbnQzWzFdO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgX2NvbnRyb2xQb2ludDQgPSBjb250cm9sUG9pbnQoe1xuICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgIHByZXZpb3VzOiBhW2kgLSAxXSxcbiAgICBuZXh0OiBhW2kgKyAxXSxcbiAgICByZXZlcnNlOiB0cnVlXG4gIH0pLFxuICAgICAgY3BlWCA9IF9jb250cm9sUG9pbnQ0WzBdLFxuICAgICAgY3BlWSA9IF9jb250cm9sUG9pbnQ0WzFdO1xuXG4gIHJldHVybiBcIkMgXCIgKyBjcHNYICsgXCIsXCIgKyBjcHNZICsgXCIgXCIgKyBjcGVYICsgXCIsXCIgKyBjcGVZICsgXCIgXCIgKyBwb2ludC54ICsgXCIsIFwiICsgcG9pbnQueTtcbn07XG5cbnZhciBQYXRocyA9IGZ1bmN0aW9uIFBhdGhzKF9yZWYyKSB7XG4gIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgcGF0aHMgPSBfcmVmMi5wYXRocztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCwgaW5kZXgpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTdmdQYXRoLCB7XG4gICAgICBrZXk6IGlkICsgXCJfX1wiICsgaW5kZXgsXG4gICAgICBwYXRoczogcGF0aC5wYXRocyxcbiAgICAgIGlkOiBpZCArIFwiX19cIiArIGluZGV4LFxuICAgICAgc3Ryb2tlV2lkdGg6IHBhdGguc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VDb2xvcjogcGF0aC5zdHJva2VDb2xvcixcbiAgICAgIGNvbW1hbmQ6IGJlemllckNvbW1hbmRcbiAgICB9KTtcbiAgfSkpO1xufTtcblxudmFyIGxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW1nLndpZHRoID4gMCkge1xuICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdCgnSW1hZ2Ugbm90IGZvdW5kJyk7XG4gICAgfSk7XG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICAgIGltZy5zcmMgPSB1cmw7XG4gICAgaW1nLnNldEF0dHJpYnV0ZSgnY3Jvc3NvcmlnaW4nLCAnYW5vbnltb3VzJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0Q2FudmFzV2l0aFZpZXdCb3goY2FudmFzKSB7XG4gIHZhciBfY2FudmFzJGZpcnN0Q2hpbGQ7XG5cbiAgdmFyIHN2Z0NhbnZhcyA9IChfY2FudmFzJGZpcnN0Q2hpbGQgPSBjYW52YXMuZmlyc3RDaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYW52YXMkZmlyc3RDaGlsZC5jbG9uZU5vZGUodHJ1ZSk7XG4gIHZhciB3aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gIHN2Z0NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCBcIiArIHdpZHRoICsgXCIgXCIgKyBoZWlnaHQpO1xuICBzdmdDYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoLnRvU3RyaW5nKCkpO1xuICBzdmdDYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQudG9TdHJpbmcoKSk7XG4gIHJldHVybiB7XG4gICAgc3ZnQ2FudmFzOiBzdmdDYW52YXMsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbnZhciBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgcGF0aHMgPSBwcm9wcy5wYXRocyxcbiAgICAgIGlzRHJhd2luZyA9IHByb3BzLmlzRHJhd2luZyxcbiAgICAgIG9uUG9pbnRlckRvd24gPSBwcm9wcy5vblBvaW50ZXJEb3duLFxuICAgICAgb25Qb2ludGVyTW92ZSA9IHByb3BzLm9uUG9pbnRlck1vdmUsXG4gICAgICBvblBvaW50ZXJVcCA9IHByb3BzLm9uUG9pbnRlclVwLFxuICAgICAgX3Byb3BzJGlkID0gcHJvcHMuaWQsXG4gICAgICBpZCA9IF9wcm9wcyRpZCA9PT0gdm9pZCAwID8gJ3JlYWN0LXNrZXRjaC1jYW52YXMnIDogX3Byb3BzJGlkLFxuICAgICAgX3Byb3BzJHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICB3aWR0aCA9IF9wcm9wcyR3aWR0aCA9PT0gdm9pZCAwID8gJzEwMCUnIDogX3Byb3BzJHdpZHRoLFxuICAgICAgX3Byb3BzJGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgIGhlaWdodCA9IF9wcm9wcyRoZWlnaHQgPT09IHZvaWQgMCA/ICcxMDAlJyA6IF9wcm9wcyRoZWlnaHQsXG4gICAgICBfcHJvcHMkY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3Byb3BzJGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gJ3JlYWN0LXNrZXRjaC1jYW52YXMnIDogX3Byb3BzJGNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjYW52YXNDb2xvciA9IHByb3BzLmNhbnZhc0NvbG9yLFxuICAgICAgY2FudmFzQ29sb3IgPSBfcHJvcHMkY2FudmFzQ29sb3IgPT09IHZvaWQgMCA/ICdyZWQnIDogX3Byb3BzJGNhbnZhc0NvbG9yLFxuICAgICAgX3Byb3BzJGJhY2tncm91bmRJbWFnID0gcHJvcHMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgYmFja2dyb3VuZEltYWdlID0gX3Byb3BzJGJhY2tncm91bmRJbWFnID09PSB2b2lkIDAgPyAnJyA6IF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyxcbiAgICAgIF9wcm9wcyRleHBvcnRXaXRoQmFjayA9IHByb3BzLmV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICBleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlID0gX3Byb3BzJGV4cG9ydFdpdGhCYWNrID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRleHBvcnRXaXRoQmFjayxcbiAgICAgIF9wcm9wcyRwcmVzZXJ2ZUJhY2tnciA9IHByb3BzLnByZXNlcnZlQmFja2dyb3VuZEltYWdlQXNwZWN0UmF0aW8sXG4gICAgICBwcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvID0gX3Byb3BzJHByZXNlcnZlQmFja2dyID09PSB2b2lkIDAgPyAnbm9uZScgOiBfcHJvcHMkcHJlc2VydmVCYWNrZ3IsXG4gICAgICBfcHJvcHMkYWxsb3dPbmx5UG9pbnQgPSBwcm9wcy5hbGxvd09ubHlQb2ludGVyVHlwZSxcbiAgICAgIGFsbG93T25seVBvaW50ZXJUeXBlID0gX3Byb3BzJGFsbG93T25seVBvaW50ID09PSB2b2lkIDAgPyAnYWxsJyA6IF9wcm9wcyRhbGxvd09ubHlQb2ludCxcbiAgICAgIF9wcm9wcyRzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgc3R5bGUgPSBfcHJvcHMkc3R5bGUgPT09IHZvaWQgMCA/IHtcbiAgICBib3JkZXI6ICcwLjA2MjVyZW0gc29saWQgIzljOWM5YycsXG4gICAgYm9yZGVyUmFkaXVzOiAnMC4yNXJlbSdcbiAgfSA6IF9wcm9wcyRzdHlsZSxcbiAgICAgIF9wcm9wcyRzdmdTdHlsZSA9IHByb3BzLnN2Z1N0eWxlLFxuICAgICAgc3ZnU3R5bGUgPSBfcHJvcHMkc3ZnU3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHN2Z1N0eWxlO1xuICB2YXIgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpOyAvLyBDb252ZXJ0cyBtb3VzZSBjb29yZGluYXRlcyB0byByZWxhdGl2ZSBjb29yZGluYXRlIGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBzdmdcblxuICB2YXIgZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyhwb2ludGVyRXZlbnQpIHtcbiAgICB2YXIgX2NhbnZhc1JlZiRjdXJyZW50LCBfd2luZG93JHNjcm9sbFgsIF93aW5kb3ckc2Nyb2xsWTtcblxuICAgIHZhciBib3VuZGluZ0FyZWEgPSAoX2NhbnZhc1JlZiRjdXJyZW50ID0gY2FudmFzUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfY2FudmFzUmVmJGN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSAoX3dpbmRvdyRzY3JvbGxYID0gd2luZG93LnNjcm9sbFgpICE9IG51bGwgPyBfd2luZG93JHNjcm9sbFggOiAwO1xuICAgIHZhciBzY3JvbGxUb3AgPSAoX3dpbmRvdyRzY3JvbGxZID0gd2luZG93LnNjcm9sbFkpICE9IG51bGwgPyBfd2luZG93JHNjcm9sbFkgOiAwO1xuXG4gICAgaWYgKCFib3VuZGluZ0FyZWEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0ge1xuICAgICAgeDogcG9pbnRlckV2ZW50LnBhZ2VYIC0gYm91bmRpbmdBcmVhLmxlZnQgLSBzY3JvbGxMZWZ0LFxuICAgICAgeTogcG9pbnRlckV2ZW50LnBhZ2VZIC0gYm91bmRpbmdBcmVhLnRvcCAtIHNjcm9sbFRvcFxuICAgIH07XG4gICAgcmV0dXJuIHBvaW50O1xuICB9O1xuICAvKiBNb3VzZSBIYW5kbGVycyAtIE1vdXNlIGRvd24sIG1vdmUgYW5kIHVwICovXG5cblxuICB2YXIgaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bihldmVudCkge1xuICAgIC8vIEFsbG93IG9ubHkgY2hvc2VuIHBvaW50ZXIgdHlwZVxuICAgIGlmIChhbGxvd09ubHlQb2ludGVyVHlwZSAhPT0gJ2FsbCcgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09IGFsbG93T25seVBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgIHZhciBwb2ludCA9IGdldENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICBvblBvaW50ZXJEb3duKHBvaW50KTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZShldmVudCkge1xuICAgIGlmICghaXNEcmF3aW5nKSByZXR1cm47IC8vIEFsbG93IG9ubHkgY2hvc2VuIHBvaW50ZXIgdHlwZVxuXG4gICAgaWYgKGFsbG93T25seVBvaW50ZXJUeXBlICE9PSAnYWxsJyAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gYWxsb3dPbmx5UG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBnZXRDb29yZGluYXRlcyhldmVudCk7XG4gICAgb25Qb2ludGVyTW92ZShwb2ludCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcChldmVudCkge1xuICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiBldmVudC5idXR0b24gIT09IDApIHJldHVybjsgLy8gQWxsb3cgb25seSBjaG9zZW4gcG9pbnRlciB0eXBlXG5cbiAgICBpZiAoYWxsb3dPbmx5UG9pbnRlclR5cGUgIT09ICdhbGwnICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSBhbGxvd09ubHlQb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uUG9pbnRlclVwKCk7XG4gIH07XG4gIC8qIE1vdXNlIEhhbmRsZXJzIGVuZHMgKi9cblxuXG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cG9ydEltYWdlOiBmdW5jdGlvbiBleHBvcnRJbWFnZShpbWFnZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMsIF9nZXRDYW52YXNXaXRoVmlld0JveCwgc3ZnQ2FudmFzLCBfd2lkdGgsIF9oZWlnaHQsIGNhbnZhc1NrZXRjaCwgbG9hZEltYWdlUHJvbWlzZXMsIGltZztcblxuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW52YXMgbm90IHJlbmRlcmVkIHlldCcpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF9nZXRDYW52YXNXaXRoVmlld0JveCA9IGdldENhbnZhc1dpdGhWaWV3Qm94KGNhbnZhcyksIHN2Z0NhbnZhcyA9IF9nZXRDYW52YXNXaXRoVmlld0JveC5zdmdDYW52YXMsIF93aWR0aCA9IF9nZXRDYW52YXNXaXRoVmlld0JveC53aWR0aCwgX2hlaWdodCA9IF9nZXRDYW52YXNXaXRoVmlld0JveC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1NrZXRjaCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIiArIGJ0b2Eoc3ZnQ2FudmFzLm91dGVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEltYWdlKGNhbnZhc1NrZXRjaCk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICBsb2FkSW1hZ2VQcm9taXNlcyA9IFtfY29udGV4dC50MF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkSW1hZ2UoYmFja2dyb3VuZEltYWdlKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgaW1nID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEltYWdlUHJvbWlzZXMucHVzaChpbWcpO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTg7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZSBwcm9wcyBpcyBzZXQgd2l0aG91dCBhIHZhbGlkIGJhY2tncm91bmQgaW1hZ2UgVVJMLiBUaGlzIG9wdGlvbiBpcyBpZ25vcmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKGxvYWRJbWFnZVByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChpbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBfd2lkdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgX2hlaWdodC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHJlbmRlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ2FudmFzIG5vdCByZW5kZXJlZCB5ZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZW5kZXJDYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvXCIgKyBpbWFnZVR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjQ7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF9jb250ZXh0LnQyKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgMjRdLCBbMTEsIDE4XV0pO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuICAgICAgfSxcbiAgICAgIGV4cG9ydFN2ZzogZnVuY3Rpb24gZXhwb3J0U3ZnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2NhbnZhc1JlZiRjdXJyZW50MjtcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IChfY2FudmFzUmVmJGN1cnJlbnQyID0gY2FudmFzUmVmLmN1cnJlbnQpICE9IG51bGwgPyBfY2FudmFzUmVmJGN1cnJlbnQyIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKGNhbnZhcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgX3N2Z0NhbnZhcyRxdWVyeVNlbGVjLCBfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMyO1xuXG4gICAgICAgICAgICAgIHZhciBfZ2V0Q2FudmFzV2l0aFZpZXdCb3gyID0gZ2V0Q2FudmFzV2l0aFZpZXdCb3goY2FudmFzKSxcbiAgICAgICAgICAgICAgICAgIHN2Z0NhbnZhcyA9IF9nZXRDYW52YXNXaXRoVmlld0JveDIuc3ZnQ2FudmFzO1xuXG4gICAgICAgICAgICAgIGlmIChleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzdmdDYW52YXMub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAoX3N2Z0NhbnZhcyRxdWVyeVNlbGVjID0gc3ZnQ2FudmFzLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBpZCArIFwiX19iYWNrZ3JvdW5kXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX3N2Z0NhbnZhcyRxdWVyeVNlbGVjLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAoX3N2Z0NhbnZhcyRxdWVyeVNlbGVjMiA9IHN2Z0NhbnZhcy5xdWVyeVNlbGVjdG9yKFwiI1wiICsgaWQgKyBcIl9fY2FudmFzLWJhY2tncm91bmRcIikpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMyLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGNhbnZhc0NvbG9yKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdmdDYW52YXMub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2FudmFzIG5vdCBsb2FkZWQnKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIC8qIEFkZCBldmVudCBsaXN0ZW5lciB0byBNb3VzZSB1cCBhbmQgVG91Y2ggdXAgdG9cclxuICByZWxlYXNlIGRyYXdpbmcgZXZlbiB3aGVuIHBvaW50IGdvZXMgb3V0IG9mIGNhbnZhcyAqL1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgaGFuZGxlUG9pbnRlclVwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgaGFuZGxlUG9pbnRlclVwKTtcbiAgICB9O1xuICB9LCBbaGFuZGxlUG9pbnRlclVwXSk7XG4gIHZhciBlcmFzZXJQYXRocyA9IHBhdGhzLmZpbHRlcihmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiAhcGF0aC5kcmF3TW9kZTtcbiAgfSk7XG4gIHZhciBjdXJyZW50R3JvdXAgPSAwO1xuICB2YXIgcGF0aEdyb3VwcyA9IHBhdGhzLnJlZHVjZShmdW5jdGlvbiAoYXJyYXlHcm91cCwgcGF0aCkge1xuICAgIGlmICghcGF0aC5kcmF3TW9kZSkge1xuICAgICAgY3VycmVudEdyb3VwICs9IDE7XG4gICAgICByZXR1cm4gYXJyYXlHcm91cDtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXlHcm91cFtjdXJyZW50R3JvdXBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFycmF5R3JvdXBbY3VycmVudEdyb3VwXSA9IFtdO1xuICAgIH1cblxuICAgIGFycmF5R3JvdXBbY3VycmVudEdyb3VwXS5wdXNoKHBhdGgpO1xuICAgIHJldHVybiBhcnJheUdyb3VwO1xuICB9LCBbW11dKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0sIHN0eWxlKSxcbiAgICBcInRvdWNoLWFjdGlvblwiOiBcIm5vbmVcIixcbiAgICBvblBvaW50ZXJEb3duOiBoYW5kbGVQb2ludGVyRG93bixcbiAgICBvblBvaW50ZXJNb3ZlOiBoYW5kbGVQb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogaGFuZGxlUG9pbnRlclVwXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHZlcnNpb246IFwiMS4xXCIsXG4gICAgYmFzZVByb2ZpbGU6IFwiZnVsbFwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgeG1sbnNYbGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgIH0sIHN2Z1N0eWxlKSxcbiAgICBpZDogaWRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGlkOiBpZCArIFwiX19lcmFzZXItc3Ryb2tlLWdyb3VwXCIsXG4gICAgZGlzcGxheTogXCJub25lXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGlkOiBpZCArIFwiX19tYXNrLWJhY2tncm91bmRcIixcbiAgICB4OiBcIjBcIixcbiAgICB5OiBcIjBcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIGVyYXNlclBhdGhzLm1hcChmdW5jdGlvbiAoZXJhc2VyUGF0aCwgaSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFN2Z1BhdGgsIHtcbiAgICAgIGtleTogaWQgKyBcIl9fZXJhc2VyLVwiICsgaSxcbiAgICAgIGlkOiBpZCArIFwiX19lcmFzZXItXCIgKyBpLFxuICAgICAgcGF0aHM6IGVyYXNlclBhdGgucGF0aHMsXG4gICAgICBzdHJva2VDb2xvcjogXCIjMDAwMDAwXCIsXG4gICAgICBzdHJva2VXaWR0aDogZXJhc2VyUGF0aC5zdHJva2VXaWR0aFxuICAgIH0pO1xuICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIGJhY2tncm91bmRJbWFnZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0dGVyblwiLCB7XG4gICAgaWQ6IGlkICsgXCJfX2JhY2tncm91bmRcIixcbiAgICB4OiBcIjBcIixcbiAgICB5OiBcIjBcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1hZ2VcIiwge1xuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIHhsaW5rSHJlZjogYmFja2dyb3VuZEltYWdlLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IHByZXNlcnZlQmFja2dyb3VuZEltYWdlQXNwZWN0UmF0aW9cbiAgfSkpLCBlcmFzZXJQYXRocy5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcIm1hc2tcIiwge1xuICAgICAgaWQ6IGlkICsgXCJfX2VyYXNlci1tYXNrLVwiICsgaSxcbiAgICAgIGtleTogaWQgKyBcIl9fZXJhc2VyLW1hc2stXCIgKyBpLFxuICAgICAgbWFza1VuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidXNlXCIsIHtcbiAgICAgIGhyZWY6IFwiI1wiICsgaWQgKyBcIl9fbWFzay1iYWNrZ3JvdW5kXCJcbiAgICB9KSwgQXJyYXkuZnJvbSh7XG4gICAgICBsZW5ndGg6IGVyYXNlclBhdGhzLmxlbmd0aCAtIGlcbiAgICB9LCBmdW5jdGlvbiAoXywgaikge1xuICAgICAgcmV0dXJuIGogKyBpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIiwge1xuICAgICAgICBrZXk6IGsudG9TdHJpbmcoKSxcbiAgICAgICAgaHJlZjogXCIjXCIgKyBpZCArIFwiX19lcmFzZXItXCIgKyBrLnRvU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgaWQ6IGlkICsgXCJfX2NhbnZhcy1iYWNrZ3JvdW5kLWdyb3VwXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGlkOiBpZCArIFwiX19jYW52YXMtYmFja2dyb3VuZFwiLFxuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGZpbGw6IGJhY2tncm91bmRJbWFnZSA/IFwidXJsKCNcIiArIGlkICsgXCJfX2JhY2tncm91bmQpXCIgOiBjYW52YXNDb2xvclxuICB9KSksIHBhdGhHcm91cHMubWFwKGZ1bmN0aW9uIChwYXRoR3JvdXAsIGkpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgaWQ6IGlkICsgXCJfX3N0cm9rZS1ncm91cC1cIiArIGksXG4gICAgICBrZXk6IGlkICsgXCJfX3N0cm9rZS1ncm91cC1cIiArIGksXG4gICAgICBtYXNrOiBcInVybCgjXCIgKyBpZCArIFwiX19lcmFzZXItbWFzay1cIiArIGkgKyBcIilcIlxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGF0aHMsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHBhdGhzOiBwYXRoR3JvdXBcbiAgICB9KSk7XG4gIH0pKSk7XG59KTtcblxudmFyIFJlYWN0U2tldGNoQ2FudmFzID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRpZCA9IHByb3BzLmlkLFxuICAgICAgaWQgPSBfcHJvcHMkaWQgPT09IHZvaWQgMCA/ICdyZWFjdC1za2V0Y2gtY2FudmFzJyA6IF9wcm9wcyRpZCxcbiAgICAgIF9wcm9wcyR3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgd2lkdGggPSBfcHJvcHMkd2lkdGggPT09IHZvaWQgMCA/ICcxMDAlJyA6IF9wcm9wcyR3aWR0aCxcbiAgICAgIF9wcm9wcyRoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfcHJvcHMkaGVpZ2h0ID09PSB2b2lkIDAgPyAnMTAwJScgOiBfcHJvcHMkaGVpZ2h0LFxuICAgICAgX3Byb3BzJGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9wcm9wcyRjbGFzc05hbWUgPT09IHZvaWQgMCA/ICcnIDogX3Byb3BzJGNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjYW52YXNDb2xvciA9IHByb3BzLmNhbnZhc0NvbG9yLFxuICAgICAgY2FudmFzQ29sb3IgPSBfcHJvcHMkY2FudmFzQ29sb3IgPT09IHZvaWQgMCA/ICd3aGl0ZScgOiBfcHJvcHMkY2FudmFzQ29sb3IsXG4gICAgICBfcHJvcHMkc3Ryb2tlQ29sb3IgPSBwcm9wcy5zdHJva2VDb2xvcixcbiAgICAgIHN0cm9rZUNvbG9yID0gX3Byb3BzJHN0cm9rZUNvbG9yID09PSB2b2lkIDAgPyAncmVkJyA6IF9wcm9wcyRzdHJva2VDb2xvcixcbiAgICAgIF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyA9IHByb3BzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZSA9IF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyA9PT0gdm9pZCAwID8gJycgOiBfcHJvcHMkYmFja2dyb3VuZEltYWcsXG4gICAgICBfcHJvcHMkZXhwb3J0V2l0aEJhY2sgPSBwcm9wcy5leHBvcnRXaXRoQmFja2dyb3VuZEltYWdlLFxuICAgICAgZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZSA9IF9wcm9wcyRleHBvcnRXaXRoQmFjayA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZXhwb3J0V2l0aEJhY2ssXG4gICAgICBfcHJvcHMkcHJlc2VydmVCYWNrZ3IgPSBwcm9wcy5wcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvLFxuICAgICAgcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpbyA9IF9wcm9wcyRwcmVzZXJ2ZUJhY2tnciA9PT0gdm9pZCAwID8gJ25vbmUnIDogX3Byb3BzJHByZXNlcnZlQmFja2dyLFxuICAgICAgX3Byb3BzJHN0cm9rZVdpZHRoID0gcHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9wcm9wcyRzdHJva2VXaWR0aCA9PT0gdm9pZCAwID8gNCA6IF9wcm9wcyRzdHJva2VXaWR0aCxcbiAgICAgIF9wcm9wcyRlcmFzZXJXaWR0aCA9IHByb3BzLmVyYXNlcldpZHRoLFxuICAgICAgZXJhc2VyV2lkdGggPSBfcHJvcHMkZXJhc2VyV2lkdGggPT09IHZvaWQgMCA/IDggOiBfcHJvcHMkZXJhc2VyV2lkdGgsXG4gICAgICBfcHJvcHMkYWxsb3dPbmx5UG9pbnQgPSBwcm9wcy5hbGxvd09ubHlQb2ludGVyVHlwZSxcbiAgICAgIGFsbG93T25seVBvaW50ZXJUeXBlID0gX3Byb3BzJGFsbG93T25seVBvaW50ID09PSB2b2lkIDAgPyAnYWxsJyA6IF9wcm9wcyRhbGxvd09ubHlQb2ludCxcbiAgICAgIF9wcm9wcyRzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgc3R5bGUgPSBfcHJvcHMkc3R5bGUgPT09IHZvaWQgMCA/IHtcbiAgICBib3JkZXI6ICcwLjA2MjVyZW0gc29saWQgIzljOWM5YycsXG4gICAgYm9yZGVyUmFkaXVzOiAnMC4yNXJlbSdcbiAgfSA6IF9wcm9wcyRzdHlsZSxcbiAgICAgIF9wcm9wcyRzdmdTdHlsZSA9IHByb3BzLnN2Z1N0eWxlLFxuICAgICAgc3ZnU3R5bGUgPSBfcHJvcHMkc3ZnU3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHN2Z1N0eWxlLFxuICAgICAgX3Byb3BzJG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkNoYW5nZSA9IF9wcm9wcyRvbkNoYW5nZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKF9wYXRocykge30gOiBfcHJvcHMkb25DaGFuZ2UsXG4gICAgICBfcHJvcHMkb25TdHJva2UgPSBwcm9wcy5vblN0cm9rZSxcbiAgICAgIG9uU3Ryb2tlID0gX3Byb3BzJG9uU3Ryb2tlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoX3BhdGgsIF9pc0VyYXNlcikge30gOiBfcHJvcHMkb25TdHJva2UsXG4gICAgICBfcHJvcHMkd2l0aFRpbWVzdGFtcCA9IHByb3BzLndpdGhUaW1lc3RhbXAsXG4gICAgICB3aXRoVGltZXN0YW1wID0gX3Byb3BzJHdpdGhUaW1lc3RhbXAgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHdpdGhUaW1lc3RhbXA7XG4gIHZhciBzdmdDYW52YXMgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUodHJ1ZSksXG4gICAgICBkcmF3TW9kZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldERyYXdNb2RlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgaXNEcmF3aW5nID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldElzRHJhd2luZyA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShbXSksXG4gICAgICByZXNldFN0YWNrID0gX1JlYWN0JHVzZVN0YXRlM1swXSxcbiAgICAgIHNldFJlc2V0U3RhY2sgPSBfUmVhY3QkdXNlU3RhdGUzWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGU0ID0gUmVhY3QudXNlU3RhdGUoW10pLFxuICAgICAgdW5kb1N0YWNrID0gX1JlYWN0JHVzZVN0YXRlNFswXSxcbiAgICAgIHNldFVuZG9TdGFjayA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTUgPSBSZWFjdC51c2VTdGF0ZShbXSksXG4gICAgICBjdXJyZW50UGF0aHMgPSBfUmVhY3QkdXNlU3RhdGU1WzBdLFxuICAgICAgc2V0Q3VycmVudFBhdGhzID0gX1JlYWN0JHVzZVN0YXRlNVsxXTtcblxuICB2YXIgbGlmdFN0cm9rZVVwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBfY3VycmVudFBhdGhzJHNsaWNlJCwgX2N1cnJlbnRQYXRocyRzbGljZTtcblxuICAgIHZhciBsYXN0U3Ryb2tlID0gKF9jdXJyZW50UGF0aHMkc2xpY2UkID0gKF9jdXJyZW50UGF0aHMkc2xpY2UgPSBjdXJyZW50UGF0aHMuc2xpY2UoLTEpKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRQYXRocyRzbGljZVswXSkgIT0gbnVsbCA/IF9jdXJyZW50UGF0aHMkc2xpY2UkIDogbnVsbDtcblxuICAgIGlmIChsYXN0U3Ryb2tlID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHN0cm9rZSBmb3VuZCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvblN0cm9rZShsYXN0U3Ryb2tlLCAhbGFzdFN0cm9rZS5kcmF3TW9kZSk7XG4gIH0sIFtpc0RyYXdpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBsaWZ0U3Ryb2tlVXAoKTtcbiAgfSwgW2lzRHJhd2luZ10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIG9uQ2hhbmdlKGN1cnJlbnRQYXRocyk7XG4gIH0sIFtjdXJyZW50UGF0aHNdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJhc2VNb2RlOiBmdW5jdGlvbiBlcmFzZU1vZGUoZXJhc2UpIHtcbiAgICAgICAgc2V0RHJhd01vZGUoIWVyYXNlKTtcbiAgICAgIH0sXG4gICAgICBjbGVhckNhbnZhczogZnVuY3Rpb24gY2xlYXJDYW52YXMoKSB7XG4gICAgICAgIHNldFJlc2V0U3RhY2soW10uY29uY2F0KGN1cnJlbnRQYXRocykpO1xuICAgICAgICBzZXRDdXJyZW50UGF0aHMoW10pO1xuICAgICAgfSxcbiAgICAgIHVuZG86IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIGxhc3QgcmVzZXQgdGhlblxuICAgICAgICBpZiAocmVzZXRTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBzZXRDdXJyZW50UGF0aHMoW10uY29uY2F0KHJlc2V0U3RhY2spKTtcbiAgICAgICAgICBzZXRSZXNldFN0YWNrKFtdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRVbmRvU3RhY2soZnVuY3Rpb24gKHVuZG9TdGFjaykge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQodW5kb1N0YWNrLCBjdXJyZW50UGF0aHMuc2xpY2UoLTEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXRocy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlZG86IGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gUmVkb1xuICAgICAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoY3VycmVudFBhdGhzLCB1bmRvU3RhY2suc2xpY2UoLTEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFVuZG9TdGFjayhmdW5jdGlvbiAodW5kb1N0YWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZG9TdGFjay5zbGljZSgwLCAtMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGV4cG9ydEltYWdlOiBmdW5jdGlvbiBleHBvcnRJbWFnZShpbWFnZVR5cGUpIHtcbiAgICAgICAgdmFyIF9zdmdDYW52YXMkY3VycmVudDtcblxuICAgICAgICB2YXIgZXhwb3J0SW1hZ2UgPSAoX3N2Z0NhbnZhcyRjdXJyZW50ID0gc3ZnQ2FudmFzLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnQ2FudmFzJGN1cnJlbnQuZXhwb3J0SW1hZ2U7XG5cbiAgICAgICAgaWYgKCFleHBvcnRJbWFnZSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdFeHBvcnQgZnVuY3Rpb24gY2FsbGVkIGJlZm9yZSBjYW52YXMgbG9hZGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydEltYWdlKGltYWdlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHBvcnRTdmc6IGZ1bmN0aW9uIGV4cG9ydFN2ZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgX3N2Z0NhbnZhcyRjdXJyZW50MjtcblxuICAgICAgICAgIHZhciBleHBvcnRTdmcgPSAoX3N2Z0NhbnZhcyRjdXJyZW50MiA9IHN2Z0NhbnZhcy5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3N2Z0NhbnZhcyRjdXJyZW50Mi5leHBvcnRTdmc7XG5cbiAgICAgICAgICBpZiAoIWV4cG9ydFN2Zykge1xuICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdFeHBvcnQgZnVuY3Rpb24gY2FsbGVkIGJlZm9yZSBjYW52YXMgbG9hZGVkJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRTdmcoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXhwb3J0UGF0aHM6IGZ1bmN0aW9uIGV4cG9ydFBhdGhzKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlKGN1cnJlbnRQYXRocyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbG9hZFBhdGhzOiBmdW5jdGlvbiBsb2FkUGF0aHMocGF0aHMpIHtcbiAgICAgICAgc2V0Q3VycmVudFBhdGhzKGZ1bmN0aW9uIChjdXJyZW50UGF0aHMpIHtcbiAgICAgICAgICByZXR1cm4gW10uY29uY2F0KGN1cnJlbnRQYXRocywgcGF0aHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRTa2V0Y2hpbmdUaW1lOiBmdW5jdGlvbiBnZXRTa2V0Y2hpbmdUaW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGlmICghd2l0aFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlNldCAnd2l0aFRpbWVzdGFtcCcgcHJvcCB0byBnZXQgc2tldGNoaW5nIHRpbWVcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2tldGNoaW5nVGltZSA9IGN1cnJlbnRQYXRocy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsU2tldGNoaW5nVGltZSwgcGF0aCkge1xuICAgICAgICAgICAgICB2YXIgX3BhdGgkc3RhcnRUaW1lc3RhbXAsIF9wYXRoJGVuZFRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lc3RhbXAgPSAoX3BhdGgkc3RhcnRUaW1lc3RhbXAgPSBwYXRoLnN0YXJ0VGltZXN0YW1wKSAhPSBudWxsID8gX3BhdGgkc3RhcnRUaW1lc3RhbXAgOiAwO1xuICAgICAgICAgICAgICB2YXIgZW5kVGltZXN0YW1wID0gKF9wYXRoJGVuZFRpbWVzdGFtcCA9IHBhdGguZW5kVGltZXN0YW1wKSAhPSBudWxsID8gX3BhdGgkZW5kVGltZXN0YW1wIDogMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsU2tldGNoaW5nVGltZSArIChlbmRUaW1lc3RhbXAgLSBzdGFydFRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJlc29sdmUoc2tldGNoaW5nVGltZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVzZXRDYW52YXM6IGZ1bmN0aW9uIHJlc2V0Q2FudmFzKCkge1xuICAgICAgICBzZXRSZXNldFN0YWNrKFtdKTtcbiAgICAgICAgc2V0VW5kb1N0YWNrKFtdKTtcbiAgICAgICAgc2V0Q3VycmVudFBhdGhzKFtdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICB2YXIgaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bihwb2ludCkge1xuICAgIHNldElzRHJhd2luZyh0cnVlKTtcbiAgICBzZXRVbmRvU3RhY2soW10pO1xuICAgIHZhciBzdHJva2UgPSB7XG4gICAgICBkcmF3TW9kZTogZHJhd01vZGUsXG4gICAgICBzdHJva2VDb2xvcjogZHJhd01vZGUgPyBzdHJva2VDb2xvciA6ICcjMDAwMDAwJyxcbiAgICAgIHN0cm9rZVdpZHRoOiBkcmF3TW9kZSA/IHN0cm9rZVdpZHRoIDogZXJhc2VyV2lkdGgsXG4gICAgICBwYXRoczogW3BvaW50XVxuICAgIH07XG5cbiAgICBpZiAod2l0aFRpbWVzdGFtcCkge1xuICAgICAgc3Ryb2tlID0gX2V4dGVuZHMoe30sIHN0cm9rZSwge1xuICAgICAgICBzdGFydFRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgZW5kVGltZXN0YW1wOiAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChjdXJyZW50UGF0aHMsIFtzdHJva2VdKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZShwb2ludCkge1xuICAgIGlmICghaXNEcmF3aW5nKSByZXR1cm47XG4gICAgdmFyIGN1cnJlbnRTdHJva2UgPSBjdXJyZW50UGF0aHMuc2xpY2UoLTEpWzBdO1xuXG4gICAgdmFyIHVwZGF0ZWRTdHJva2UgPSBfZXh0ZW5kcyh7fSwgY3VycmVudFN0cm9rZSwge1xuICAgICAgcGF0aHM6IFtdLmNvbmNhdChjdXJyZW50U3Ryb2tlLnBhdGhzLCBbcG9pbnRdKVxuICAgIH0pO1xuXG4gICAgc2V0Q3VycmVudFBhdGhzKGZ1bmN0aW9uIChjdXJyZW50UGF0aHMpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoY3VycmVudFBhdGhzLnNsaWNlKDAsIC0xKSwgW3VwZGF0ZWRTdHJva2VdKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlclVwKCkge1xuICAgIHZhciBfY3VycmVudFBhdGhzJHNsaWNlJDIsIF9jdXJyZW50UGF0aHMkc2xpY2UyO1xuXG4gICAgaWYgKCFpc0RyYXdpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJc0RyYXdpbmcoZmFsc2UpO1xuXG4gICAgaWYgKCF3aXRoVGltZXN0YW1wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRTdHJva2UgPSAoX2N1cnJlbnRQYXRocyRzbGljZSQyID0gKF9jdXJyZW50UGF0aHMkc2xpY2UyID0gY3VycmVudFBhdGhzLnNsaWNlKC0xKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50UGF0aHMkc2xpY2UyWzBdKSAhPSBudWxsID8gX2N1cnJlbnRQYXRocyRzbGljZSQyIDogbnVsbDtcblxuICAgIGlmIChjdXJyZW50U3Ryb2tlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZWRTdHJva2UgPSBfZXh0ZW5kcyh7fSwgY3VycmVudFN0cm9rZSwge1xuICAgICAgZW5kVGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgfSk7XG5cbiAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChjdXJyZW50UGF0aHMuc2xpY2UoMCwgLTEpLCBbdXBkYXRlZFN0cm9rZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENhbnZhcywge1xuICAgIHJlZjogc3ZnQ2FudmFzLFxuICAgIGlkOiBpZCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY2FudmFzQ29sb3I6IGNhbnZhc0NvbG9yLFxuICAgIGJhY2tncm91bmRJbWFnZTogYmFja2dyb3VuZEltYWdlLFxuICAgIGV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2U6IGV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UsXG4gICAgcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpbzogcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpbyxcbiAgICBhbGxvd09ubHlQb2ludGVyVHlwZTogYWxsb3dPbmx5UG9pbnRlclR5cGUsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHN2Z1N0eWxlOiBzdmdTdHlsZSxcbiAgICBwYXRoczogY3VycmVudFBhdGhzLFxuICAgIGlzRHJhd2luZzogaXNEcmF3aW5nLFxuICAgIG9uUG9pbnRlckRvd246IGhhbmRsZVBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlck1vdmU6IGhhbmRsZVBvaW50ZXJNb3ZlLFxuICAgIG9uUG9pbnRlclVwOiBoYW5kbGVQb2ludGVyVXBcbiAgfSk7XG59KTtcblxuZXhwb3J0IHsgQ2FudmFzLCBSZWFjdFNrZXRjaENhbnZhcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtc2tldGNoLWNhbnZhcy5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.esm.js\n");

/***/ })

};
;